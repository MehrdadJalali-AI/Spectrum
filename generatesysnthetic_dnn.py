# -*- coding: utf-8 -*-
"""GenerateSysnthetic_DNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RYObhz4QHwm7glfr4mX1gKhcYRkL1_Qw
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd

import tensorflow as tf
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras import regularizers
import random
from sklearn.metrics import r2_score, mean_squared_error
import matplotlib.pyplot as plt

np.random.seed(56)
random.seed(56)
tf.random.set_seed(56)


# Function to generate a spectrum as a sum of Gaussians
def generate_spectru_gaussians(amplitudes, centers):
    widthG = 18
    x_range = np.arange(2000, 2299.8, 0.2)
    return np.sum([amplitudes[i] * np.exp(-(x_range - centers[i])**2 / widthG) for i in range(len(centers))], axis=0)

# Function to generate multiple spectra as a sum of Gaussians
def generate_multiple_spectra(amplitudes, centers):
    widthG = 18
    x_range = np.arange(2300, 2000, -0.2)  # Generating inverse values

    # Initialize empty lists for frequencies and intensity ratios
    all_frequencies = []
    all_intensity_ratios = []
    all_spectra = []

    for i in range(len(centers)):
        if centers[i] == 2176:
            intensity_ratios = [5, 2, 1]
            frequencies = [2176, 2168, 2147]
        elif centers[i] == 2168:
            intensity_ratios = [3, 1]
            frequencies = [2168, 2147]
        else:
            intensity_ratios = [1]
            frequencies = [list(specificFrequencies.keys())[i]]

        all_frequencies.append(frequencies)
        all_intensity_ratios.append(intensity_ratios)

        spectrum = np.sum([amplitudes[i] * np.exp(-(x_range - frequencies[j])**2 / widthG) * intensity_ratios[j] for j in range(len(frequencies))], axis=0)
        all_spectra.append(spectrum)

    final_spectrum = np.sum(all_spectra, axis=0)

    return final_spectrum, all_frequencies, all_intensity_ratios

# Define specific frequencies and corresponding classes/labels
specificFrequencies = {
    2175: 'CeO2(110)red',
    2170: 'CeO2(110)ox',
    2176: 'CeO2(100)ox',
    2168: 'CeO2(100)red',
    2162: 'CeO2(111)red',
    2154: 'CeO2(111)ox'
}

# Generate amplitudes for spectra data
num_amplitudes = 6
num_spectra = 2500

# Generate spectra data with corresponding amplitude vectors
spectraDataAmplitudesList = []
for _ in range(num_spectra):
    amplitudes = np.random.rand(num_amplitudes)
    spectrum, _, _ = generate_multiple_spectra(amplitudes, list(specificFrequencies.keys()))
    spectraDataAmplitudesList.append((spectrum, amplitudes))
    spectrum = generate_spectru_gaussians(amplitudes, list(specificFrequencies.keys()))
    spectraDataAmplitudesList.append((spectrum, amplitudes))


# Split the data into spectra and amplitudes
spectraData = np.array([data[0] for data in spectraDataAmplitudesList])
amplitudesData = np.array([data[1] for data in spectraDataAmplitudesList])

num_samples, points_per_spectrum = spectraData.shape
num_specific_frequencies = 6
spectraData = np.reshape(spectraData, (num_samples, points_per_spectrum // num_specific_frequencies, num_specific_frequencies))


hidden_layer_structure = (91, 96)
regularization_parameter = 0.001


# Create the model
model = Sequential([
    tf.keras.layers.Flatten(input_shape=(points_per_spectrum // num_specific_frequencies, num_specific_frequencies, 1)),
    Dense(hidden_layer_structure[0], activation='relu', kernel_regularizer=regularizers.l1(regularization_parameter)),

    Dense(hidden_layer_structure[1], activation='relu', kernel_regularizer=regularizers.l1(regularization_parameter)),

    Dense(num_specific_frequencies, activation='relu')
])
# Compile the model
model.compile(optimizer='adam', loss='MAE')

# Train the model
history = model.fit(spectraData, amplitudesData, epochs=50)

model.save('/content/drive/MyDrive/Research/Spectroscopy/IR_Spectrum_Predcition/DNN_Model2.h5')


# ... [Previous code remains unchanged]

# Generate 1000 new spectra
num_new_spectra = 1000
new_spectra_data_amplitudes_list = []
for _ in range(num_new_spectra):
    amplitudes = np.random.rand(num_amplitudes)
    spectrum, _, _ = generate_multiple_spectra(amplitudes, list(specificFrequencies.keys()))
    new_spectra_data_amplitudes_list.append((spectrum, amplitudes))
    # spectrum = generate_spectru_gaussians(amplitudes, list(specificFrequencies.keys()))
    # new_spectra_data_amplitudes_list.append((spectrum, amplitudes))

# Split the new data into spectra and amplitudes
new_spectra_data = np.array([data[0] for data in new_spectra_data_amplitudes_list])
new_amplitudes_data = np.array([data[1] for data in new_spectra_data_amplitudes_list])

num_samples_new, points_per_spectrum_new = new_spectra_data.shape
new_spectra_data = np.reshape(new_spectra_data, (num_samples_new, points_per_spectrum_new // num_specific_frequencies, num_specific_frequencies))

# Predict amplitudes for the new spectra
predicted_amplitudes_new = model.predict(new_spectra_data)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(new_amplitudes_data, predicted_amplitudes_new))
print(f"Root Mean Squared Error (RMSE) on 500 new spectra: {rmse}")

